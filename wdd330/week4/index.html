<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>wdd330 Portfolio</title>
    <meta name="description" content="Week 4">
    <link rel="shortcut icon" href="../favicon.ico">
    <link rel="apple-touch-icon" href="../apple-touch-icon.png">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.1/normalize.min.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Charm&family=Montserrat&display=swap">
    <link rel="stylesheet" href="../css/style.css">
</head>
<body>
    <h1>WDD330 Portfolio</h1>
    <section class="weeklyItems">
        <h2>Week 4</h2>
        <ul>
            <li>Notes
                <ul>
                    <li><h3>Forms</h3></li>
                    <li>
                        <ul>
                            <li>Form objects can be referenced in JavaScript with: const form = document.forms['search']; where search is the name given to the form via name="search"</li>
                            <li>Likewise, control names can be used to access the control element e.g. const input = form.searchInput or const input = form['searchInput'] where searchInput is assigned to the input as name="searchInput"</li>
                            <li>The user can trigger submit via a button, input or image using type="submit"</li>
                            <li>Reset buttons are generally considered poor for usability, as they are too easy to click and then wipe out all the data thatâ€™s been entered. So think very carefully before using one in a form.</li>
                            <li>focus, blur, change are all input events you can listen for.  Also submit</li>
                            <li>HTML inputs have a value property with can be gotten or set</li>
                            <li>event.preventDefault() can also keep a page from doing what it normally would e.g. submitting a form</li>
                            <li>Other form controls</li>
                            <li>
                                <ul>
                                    <li>input - text, passwords, checkboxes, radio buttons, hidden, file uploads
                                        <ul>    
                                            <li>
                                                <label for='donation-amount'>Enter amount to donate: 
                                                    <input type='text' id ='donation-amount' name='donationAmount' value='10'>
                                                </label>
                                            </li>
                                            <li>
                                                <label for='realName'>Real Name:
                                                    <input type='password' name='realName' id='realName'>
                                                </label>
                                            </li>
                                            <li>
                                                <p>Super Powers:</p>
                                                <label for='flight'>Flight:
                                                    <input type='checkbox' id='flight' value='Flight' name='powers'>
                                                </label>
                                                <label for='strength'>Super Strength:
                                                    <input type='checkbox' id='strength' value='Strength' name='powers'>
                                                </label>
                                                <label for='speed'>Super Speed:
                                                    <input type='checkbox' id='speed' value='Super Speed' name='powers'>
                                                </label>
                                                <label for='energy'>Energy Blasts:
                                                    <input type='checkbox' id='energy' value='Energy Blasts' name='powers'>
                                                    </label>
                                                <label for='telekinesis'>Telekinesis:
                                                    <input type='checkbox' id='telekinesis' value='Telekinesis' name='powers'>
                                                </label>
                                            </li>
                                            <li>
                                                When inputs share the same name, they can be accessed as a collection with bracket notation e.g. form.powers[i].checked, form.powers[i].value
                                            </li>
                                            <li>
                                                <p>What type of hero are you?</p>
                                                <label for='hero'>Hero:
                                                    <input type='radio' name='category' value='Hero' id='hero'>
                                                </label>
                                                <label for='villain'>Villain:
                                                    <input type='radio' name='category' value='Villain' id='villain'>
                                                </label>
                                                <label for='anti-hero'>Anti-Hero:
                                                    <input type='radio' name='category' value='Antihero' id='anti-hero'>
                                                </label>
                                            </li>                                            
                                        </ul>                                        
                                    </li>
                                    <li>While type="text" is the default input, and therefore not required, it is recommended to be explicit</li>
                                    <li>select - drop down options
                                        <ul>
                                            <li>
                                                <label for='City'>Base of Operations:
                                                    <select name='city' id='city'>
                                                    <option value='' selected>Choose a City</option>
                                                    <option value='Metropolis'>Metropolis</option>
                                                    <option value='Gotham City'>Gotham City</option>
                                                    <option value='Keystone City'>Keystone City</option>
                                                    <option value='Coast City'>Coast City</option>
                                                    <option value='Star City'>Star City</option>
                                                    </select>
                                                </label>                                                
                                            </li>
                                        </ul>
                                    </li>
                                    <li>textarea - long text entry
                                        <ul>
                                            <li>
                                                <label for='origin'>Origin Story:
                                                    <textarea id='origin' name='origin' rows='20' cols='60'></textarea>
                                                </label>                                                
                                            </li>
                                        </ul>
                                    </li>
                                    <li>button - for submitting and resetting forms</li>
                                </ul>
                            </li>
                            <li>Form validation is the process of checking whether the information entered into a form is correct</li>
                            <li>Both client-side and server-side validation are recommended</li>
                            <li>Useful HTML5 validation includes: required, </li>
                            <li>Another good practice is disable the submit button until all controls are correctly validated</li>
                        </ul>
                    </li>
                    <li><h3>Object Oriented Programming</h3></li>
                    <li>Encapsulation - hides the inner workings (how something is done) in the object, exposing only essential information</li>
                    <li>Polymorphism - various objects can share the same method(s) (outlet) but can also override them with a different implementation (different fruit)</li>
                    <li>Inheritance - upgrades, adding to what came before</li>
                    <li>Although JavaScript now has classes, it still uses actual objects to create more objects (prototypal inheritance)</li>
                    <li>While an object literal can create an object: const dice = {sides:6} an object constructor function can also be used e.g. const Dice = function(sides=6) { this.sides = sides; } This way, new can be used to create the object e.g. const newDice = new Dice(); Parentheses are optional unless a default argument is needed. </li>
                    <li>Like and object literal const obj = {} vs constructor const obj = new Obj(), you can create an array literal const newArray = [...] or an array constructor const newArray = new Array(...)</li>
                    <li>Attempting to set an array constructor with just one element will instead set the array length and mark the values undefined</li>
                    <li>Modern JavaScript allows one to create a class with a constructor function inside the class {} making it look more like a class-based language</li>
                    <li>Calling the constructor method on any object will create a new object</li>
                    <li>Static or class methods are called by the class rather than an object, they can not however be called by instances of the class</li>
                    <li>A prototype property exists in one place in memory and is shared by all instances of a class and a change to one will change them all</li>
                    <li>Best practice, use class declarations rather than constructor functions</li>
                    <li>Own properties take precedence over prototype properties</li>
                    <li>Define prototype properties and methods with the Class.prototype.property = ... e.g. Turtle.prototype.food = 'Pizza';</li>
                    <li>Another best practice: Never use arrays or objects as a default value for a prototype unless they are set from within the constructor function in a class declaration</li>
                    <li>Default methods (and properties) are public</li>
                    <li>All objects ultimately inherit from Object()</li>
                    <li>Enumerable properties will show up in a for-in loop, to test use propertyIsEnumerable()</li>
                    <li>Extends is used to inherit from a class</li>
                    <li>super inside the child class refers to the parent class</li>
                    <li>Overriding toString() in a class to output something more meaningful is an example of polymorphism in action</li>
                    <li>Monkey-patching is the act of adding more methods to JavaScripts built-in objects</li>
                    <li>
                        <ul>
                            <li>e.g. Number.prototype.isEven = function() { return this%2 === 0; }</li>
                            <li>e.g. Number.prototype.isOdd = function() { return this%2 === 1; }</li>
                            <li>e.g. Array.prototype.first = function() { return this[0]; }</li>
                            <li>e.g. Array.prototype.last = function() { return this[this.length - 1]; }</li>
                            <li>e.g. Array.prototype.delete = function() { return self.splice(i, 1); }</li>
                        </ul>                        
                    </li>
                    <li>Better practice than Monkey-patching is to use extends to subclass a built-in class</li>
                    <li>All object properties have the following attributes: value, writable, enumerable, configurable (the last three are set to true as soon as an assignment (value) is made)</li>
                    <li>Object.defineProperty(obj, 'value', {value: '...', writable: false, enumerable: true, configurable: true);  Leave out a value to ensure the default value false</li>
                    <li>Object properties have either get() and set() methods OR they can have value attributes but not both</li>
                    <li>To add, include get() {...}, set(value) {...} in the Object.defineProperty method</li>
                    <li>Shallow copies (copies made by assignment) e.g. = or Object.assign(..., ...) are only copied by reference.  As a result, a change made to one object will change them all</li>
                    <li><a href="https://blog.bitsrc.io/understanding-mixins-in-javascript-de5d3e02b466" target="_blank"  rel="noopener noreferrer">mixin</a> is used to create deep object copies. Also, add lots of properties to an object at once</li>
                    <li>Use a copy function to create a deep copy<br>
                        function copy(target) {<br>
                        const object =  Object.create(Object.getPrototypeOf(target));<br>
                        mixin(object,target);<br>
                        return object;<br>
                    }
                    </li>
                    <li>When deciding to inherit or mixin, consider if an object is-a, inherit. If an object has-a, mixin</li>
                    <li>Chaining involves connecting multiple method calls together.  A function that returns this makes chaining possible</li>
                    <li>To keep from losing this scope when a function is inside a class, this is often assigned to that and that is then used in the function. self or _this are also often used</li>
                    <li>Another way to keep this in scope is to bind it at the end of the nested function e.g. function() { ... }.bind(this)</li>
                    <li>Or, when looping arrays, use for (const item of this.items) { loop has access to this }</li>
                    <li>Likewise, arrow functions will use this from the larger context</li>
                    <li>Methods can be borrowed (method name minus parentheses) and called on another object with &lt;method&gt;.call(object that wants to borrow the method)</li>
                    <li>Composition over inheritance seeks to get the banana sans gorilla (or jungle)</li>
                    <li></li>
                    <li></li>

                    <li><h3>Modern (Modular) JavaScript</h3></li>
                    <li>Best practice: write code that is loosely coupled (can be swapped out with as little disruption as possible)</li>
                    <li>Likewise, code should have high cohesion (do one thing and do it well)</li>
                    <li>One good way to modularize your JavaScript is to put it in a separate file (module)</li>
                    <li>Modules are always in strict mode</li>
                    <li>Modules have their own global space</li>
                    <li>this at the top of a module is undefined</li>
                    <li>Use export to identify which values or functions that are to be made available to import</li>
                    <li>On the other end use: import  { variable, functioin } from './file.js'; </li>
                    <li>Use import * as var from './file.js'; to get everything then access with var.variable, var.function()</li>
                    <li>Default exports (variable, function, object) can be exported by putting 'default' between the keyword 'export' and the name of what is exported</li>
                    <li>Having more than one default export will cause an error</li>
                    <li>The big difference with default exports is that you don't need to use curly braces or make any mention of the value that is being imported</li>
                    <li>Node.js uses a different syntax to export and import modules</li>
                </ul>
            </li>
            <li>Questions
                <ul>
                    <li>When a validation is added to a page and hidden with display:none (when not needed) how does this affect page readers?</li>
                    <li>If an array is constructed with something other than a number e.g. new Array("pizza") will it still set the array length and return an array of undefined values?  How many? Probably as the array length needs to be an int</li>
                    <li>What is the benefit of using a getter to return a property vs getting the property directly?</li>
                    <li>Also, if validation isn't done, why bother to use a setter?</li>
                    <li>How do you make a method enumerable or non-enumerable?</li>
                    <li>What does it mean for a module to be in strict mode?</li>
                </ul>
            </li>
            <li>Exercises
                <ul>
                    <li><a href="tic-tac-toe.html">Tic-Tac-Toe experiment</a></li>
                </ul>
            </li>
        </ul>
    </section>
</body>
</html>